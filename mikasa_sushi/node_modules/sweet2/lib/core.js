'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.filepathToUrl = filepathToUrl;
exports.renderByType = renderByType;
exports.parseCustomFields = parseCustomFields;
exports.parsePage = parsePage;
exports.getSourceFilesList = getSourceFilesList;
exports.loadSourceFiles = loadSourceFiles;
exports.getConfigFilesList = getConfigFilesList;
exports.readConfigFiles = readConfigFiles;
exports.mergeConfigs = mergeConfigs;
exports.loadConfig = loadConfig;
exports.filterDocuments = filterDocuments;
exports.orderDocuments = orderDocuments;
exports.groupDocuments = groupDocuments;
exports.getPageNumberUrl = getPageNumberUrl;
exports.paginate = paginate;
exports.makeContext = makeContext;
exports.generatePage = generatePage;
exports.generatePages = generatePages;
exports.savePage = savePage;
exports.savePages = savePages;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _fastmatter2 = require('fastmatter');

var _fastmatter3 = _interopRequireDefault(_fastmatter2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Convert file path to URL.
 *
 * @param {string} filepath
 * @return {string}
 */
function filepathToUrl(filepath) {
	var url = '/' + (0, _util.removeExtension)(filepath);
	url = url.replace(/\/index$/, '');
	if (url === '') {
		return '/';
	}
	return url;
}

/**
 * Renders source using appropriate renderer based on file extension.
 *
 * @param {string} source Source file contents.
 * @param {string} filepath Source file path.
 * @param {object} renderers {ext: renderFunction}
 * @return {string}
 */
function renderByType(source, filepath) {
	var renderers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	var extension = (0, _util.getExtension)(filepath);
	var render = renderers[extension];
	if (_lodash2.default.isFunction(render)) {
		return render(source);
	}
	return source;
}

/**
 * Return attributes object with parsed custom fields.
 *
 * @param {object} attributes
 * @param {object} fieldParsers  Custom field parsers: {name: parseFunction}
 * @return {object}
 */
function parseCustomFields(attributes, fieldParsers) {
	var parsedAttributes = {};
	for (var name in fieldParsers) {
		parsedAttributes[name] = fieldParsers[name](attributes[name], attributes);
	}
	return _extends({}, attributes, parsedAttributes);
}

/**
 * Parse front matter and render contents.
 *
 * @param {string} source Source file contents.
 * @param {string} filepath Source file path relative to `folder`.
 * @param {object} $2.renderers Content renderers: {ext: renderFunction}.
 * @param {object} $2.fieldParsers Custom field parsers: {name: parseFunction}.
 * @param {object} $2.cutTag Cut separator.
 * @return {object} { sourcePath, content, excerpt, more, url }
 */
function parsePage(source, filepath) {
	var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	var _ref$renderers = _ref.renderers;
	var renderers = _ref$renderers === undefined ? {} : _ref$renderers;
	var _ref$fieldParsers = _ref.fieldParsers;
	var fieldParsers = _ref$fieldParsers === undefined ? {} : _ref$fieldParsers;
	var cutTag = _ref.cutTag;

	var _fastmatter = (0, _fastmatter3.default)(source);

	var attributes = _fastmatter.attributes;
	var body = _fastmatter.body;

	var url = filepathToUrl(filepath);

	var content = renderByType(body, filepath, renderers);

	var excerpt = undefined,
	    more = undefined;
	if (cutTag) {
		var _content$split = content.split(cutTag);

		var _content$split2 = _slicedToArray(_content$split, 2);

		excerpt = _content$split2[0];
		more = _content$split2[1];
	}

	attributes = _extends({}, attributes, {
		sourcePath: filepath,
		content: content,
		excerpt: excerpt,
		more: more,
		url: url
	});

	attributes = parseCustomFields(attributes, fieldParsers);

	return attributes;
}

/**
 * Return list of source files.
 *
 * @param {string} folder Source folder.
 * @param {Array} types List of file extensions.
 * @return {Array}
 */
function getSourceFilesList(folder, types) {
	var typesMask = types.length > 1 ? '{' + types.join(',') + '}' : types[0];
	var mask = '**/*.' + typesMask;
	return _glob2.default.sync(mask, { cwd: folder });
}

/**
 * Load source files from a disk.
 *
 * @param {string} folder Source folder.
 * @param {Array} types List of file extensions.
 * @param {object} options { renderers, fieldParsers, cutTag }
 * @return {Array} [{ sourcePath, content, url }, ...]
 */
function loadSourceFiles(folder, types, options) {
	var files = getSourceFilesList(folder, types);
	if (!files.length) {
		console.warn('No source files found in a folder ' + _path2.default.resolve(folder) + ' with types ' + types.join(', '));
	}
	return files.map(function (filepath) {
		var source = (0, _util.readFile)(_path2.default.join(folder, filepath));
		return parsePage(source, filepath, options);
	});
}

/**
 * Return list of config files.
 *
 * @param {string} folder Configs folder.
 * @return {Array}
 */
function getConfigFilesList(folder) {
	return _glob2.default.sync(_path2.default.join(folder, '*.yml'));
}

/**
 * Read config files from a disk.
 *
 * @param {Array} files Config files list.
 * @return {object} {base: {...}, langs: {...}}
 */
function readConfigFiles(files) {
	return files.reduce(function (configs, filepath) {
		var name = (0, _util.removeExtension)(_path2.default.basename(filepath));
		if (name === 'base') {
			configs.base = (0, _util.readYamlFile)(filepath);
		} else {
			configs.langs[name] = (0, _util.readYamlFile)(filepath);
		}
		return configs;
	}, { base: {}, langs: {} });
}

/**
 * Merge base config with language specific configs.
 *
 * @param {object} configs
 * @return {object} {base: {...}} or {langs: {...}}
 */
function mergeConfigs(configs) {
	var base = configs.base;
	var langs = configs.langs;

	var baseConfig = {
		base: base
	};

	if (_lodash2.default.isEmpty(langs)) {
		return baseConfig;
	}

	return Object.keys(langs).reduce(function (merged, lang) {
		merged[lang] = _extends({}, configs.base, langs[lang]);
		return merged;
	}, baseConfig);
}

/**
 * Load config files from a disk.
 *
 * @param {string} folder Source folder.
 * @return {object} {base: {...}} or {langs: {...}}
 */
function loadConfig(folder) {
	var files = getConfigFilesList(folder);
	var configs = readConfigFiles(files);
	return mergeConfigs(configs);
}

/**
 * Filter documents.
 *
 * @param {Array} documents Documents.
 * @param {object} fields Filters by field: {lang: 'en', url: /^posts\//}
 * @return {Array}
 */
function filterDocuments(documents, fields) {
	return documents.filter(function (document) {
		for (var field in fields) {
			var value = fields[field];
			var documentValue = document[field];
			if (_lodash2.default.isRegExp(value)) {
				if (!value.test(documentValue)) {
					return false;
				}
			} else if (documentValue !== value) {
				return false;
			}
		}
		return true;
	});
}

/**
 * Order documents.
 *
 * @param {Array} documents Documents.
 * @param {Array} fields ['foo', '-bar']
 * @return {Array}
 */
function orderDocuments(documents, fields) {
	fields = (0, _util.formatFieldsForSortByOrder)(fields);
	return _lodash2.default.sortByOrder.apply(_lodash2.default, [documents].concat(_toConsumableArray(fields)));
}

/**
 * Group documents by values of a given field.
 *
 * @param {Array} documents Documents.
 * @param {String|Function} field Field name or function.
 * @return {object} {fieldValue1: [...], fieldValue2: [...], ...}
 */
function groupDocuments(documents, field) {
	return documents.reduce(function (grouped, document) {
		var value = document[field];
		if (Array.isArray(value)) {
			value.forEach(function (subValue) {
				if (!grouped[subValue]) {
					grouped[subValue] = [];
				}
				grouped[subValue].push(document);
			});
		} else {
			if (_lodash2.default.isFunction(field)) {
				value = field(document);
			}
			if (!value) {
				return grouped;
			}
			if (!grouped[value]) {
				grouped[value] = [];
			}
			grouped[value].push(document);
		}
		return grouped;
	}, {});
}

/**
 * Return URL for given page number.
 *
 * @param {string} urlPrefix
 * @param {number} pageNumber
 * @param {boolean} $2.index First page will be `index` if true.
 * @return {string}
 */
function getPageNumberUrl(urlPrefix, pageNumber) {
	var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	var index = _ref2.index;

	var url = undefined;
	if (pageNumber === 1) {
		if (index) {
			url = urlPrefix + '/index';
		} else {
			url = urlPrefix;
		}
	} else {
		url = urlPrefix + '/page/' + pageNumber;
	}
	return url.replace(/\/\//, '/');
}

/**
 * Generate documents to paginate given documents.
 *
 * @param {Array} documents Documents to paginate
 * @param {string} $1.sourcePathPrefix Source path prefix.
 * @param {string} $1.urlPrefix URL prefix.
 * @param {number} $1.documentsPerPage Documents per page.
 * @param {string} $1.layout Page layout.
 * @param {boolean} $1.index Add `index` to the first page’s source path.
 * @param {object} $1.extra Extra document options.
 * @return {Array}
 */
function paginate(documents) {
	var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	var sourcePathPrefix = _ref3.sourcePathPrefix;
	var urlPrefix = _ref3.urlPrefix;
	var documentsPerPage = _ref3.documentsPerPage;
	var layout = _ref3.layout;
	var index = _ref3.index;
	var _ref3$extra = _ref3.extra;
	var extra = _ref3$extra === undefined ? {} : _ref3$extra;

	if (sourcePathPrefix === undefined) {
		throw new Error('"sourcePathPrefix" not specified for paginate().');
	}
	if (urlPrefix === undefined) {
		throw new Error('"urlPrefix" not specified for paginate().');
	}
	if (!documentsPerPage) {
		throw new Error('"documentsPerPage" not specified for paginate().');
	}
	if (!layout) {
		throw new Error('"layout" not specified for paginate().');
	}

	var totalPages = Math.ceil(documents.length / documentsPerPage);

	return _lodash2.default.range(totalPages).map(function (pageNumber) {
		pageNumber++;
		var sourcePath = getPageNumberUrl(sourcePathPrefix, pageNumber, { index: index });
		var url = getPageNumberUrl(urlPrefix, pageNumber);
		var begin = (pageNumber - 1) * documentsPerPage;
		return _extends({}, extra, {
			previousUrl: pageNumber > 1 ? getPageNumberUrl(urlPrefix, pageNumber - 1) : null,
			nextUrl: pageNumber < totalPages ? getPageNumberUrl(urlPrefix, pageNumber + 1) : null,
			documents: documents.slice(begin, begin + documentsPerPage),
			documentsTotal: documents.length,
			sourcePath: sourcePath,
			layout: layout,
			url: url
		});
	});
}

/**
 * Create context for page rendering: merges document, config and helpers into one object.
 *
 * @param {object} document
 * @param {object} config
 * @param {object} helpers
 * @return {object}
 */
function makeContext(document, config, helpers) {
	return _extends({}, helpers, {
		config: config
	}, document);
}

/**
 * Generate page.
 *
 * @param {object} document
 * @param {object} config
 * @param {object} helpers
 * @param {object} renderers {extension: renderFunction}
 * @return {object} { pagePath, content }
 */
function generatePage(document, config, helpers, renderers) {
	if (!document.sourcePath) {
		throw new Error('Source path not specified. Add "sourcePath" front matter field.');
	}
	if (!document.layout) {
		throw new Error('Layout not specified for ' + document.sourcePath + '. Add "layout" front matter field.');
	}

	var _$pairs$shift = _lodash2.default.pairs(renderers).shift();

	var _$pairs$shift2 = _slicedToArray(_$pairs$shift, 2);

	var templateExtension = _$pairs$shift2[0];
	var render = _$pairs$shift2[1];

	var templateFile = document.layout + '.' + templateExtension;

	var pageContext = makeContext(document, config, helpers);
	var content = render(templateFile, pageContext);

	var pageExtension = (0, _util.getExtension)(document.layout);
	if (!pageExtension) {
		pageExtension = 'html';
	}
	var pagePath = (0, _util.removeExtension)(document.sourcePath) + ('.' + pageExtension);

	return {
		pagePath: pagePath,
		content: content
	};
}

/**
 * Generate pages.
 *
 * @param {Array} documents
 * @param {object} config
 * @param {object} helpers
 * @param {object} renderers {extension: renderFunction}
 * @return {Array} [{ pagePath, content }, ...]
 */
function generatePages(documents, config, helpers, renderers) {
	return documents.map(function (document) {
		return generatePage(document, config, helpers, renderers);
	});
}

/**
 * Saves page to a disk.
 *
 * @param {object} page
 * @param {string} folder Folder to save files.
 */
function savePage(page, folder) {
	(0, _util.writeFile)(_path2.default.join(folder, page.pagePath), page.content);
}

/**
 * Saves pages to a disk.
 *
 * @param {Array} pages
 * @param {string} folder Folder to save files.
 */
function savePages(pages, folder) {
	pages.forEach(function (page) {
		return savePage(page, folder);
	});
}